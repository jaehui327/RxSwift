# Chapter 1: Hello RxSwift 

## RxSwift

옵저버블 시퀀스 및 함수 스타일 연산자를 사용하여,

 비동기 및 이벤트 기반 코드를 작성하기위한 라이브러리

스케줄러를 통해 매개 변수화된 실행을 허용

본질적으로 RxSwift는, 

코드가 새로운 데이터에 반응하고 순차적으로 격리 된 방식으로 처리 할 수 있도록 함

비동기 프로그램 개발을 단순화

# 1.1 비동기 프로그래밍 소개

![](./images/1.png)

- 버튼 탭에 반응
- 텍스트 필드가 포커스를 잃을 때 키보드 애니메이션
- 인터넷으로부터 큰 사진 다운로드
- 디스크에 데이터 비트 저장
- 오디오 재생

→ 이 모든 일들이 동시에 일어나는 것처럼 보임

→ 키보드가 화면 밖으로 애니메이션될 때마다 앱의 오디오는 애니메이션이 끝날 때까지 일시 중지되지 않음

→ 프로그램의 모든 비트는 서로 실행을 차단하지 않음

→ iOS는 서로 다른 스레드에서 서로 다른 작업을 수행하고 장치 CPU의 서로 다른 코어에서 수행할 수 있는 모든 종류의 API를 제공함

그러나, 실제로 병렬로 실행되는 코드를 작성하는 것은 다소 복잡하다

특히 서로 다른 코드 비트가 동일한 데이터 조각으로 작업해야하는 경우

어떤 코드가 먼저 데이터를 업데이트하는지 또는 어떤 코드가 최신 값을 읽었는지 알기 어려움

## Cocoa 및 UIKit 비동기 API

Apple은 항상 비동기 코드 작성에 도움이되는 수많은 API를 iOS SDK에 제공했다

- NotificationCenter

    사용자가 기기의 방향을 변경하거나 화면에 표시되거나 숨겨지는 소프트웨어 키보드와 같은 관심 이벤트가 발생할 때마다 코드를 실행

- Delegate Pattern

    다른 개체를 대신하거나 조정하여 작동하는 개체를 정의

- Grand Central DIspatch

    작업 실행을 추상화하는 데 도움

    코드 블록이 순차적으로, 동시에 또는 지정된 지연 후에 실행되도록 예약 가능

- Closures

    코드에서 전달할 수 있는 분리 된 코드 조각

- Combine

    iOS 13에서 도입되고 사용 가능한 Swift로 반응형 비동기 코드를 작성하기 위한 Apple의 자체 프레임워크

대부분의 일반적인 클래스는 비동기식으로 수행되며 모든 UI 구성 요소는 기본적으로 비동기적이기 때문에 앱 코드 전체가 어떤 순서로 실행되는지 가정할 수 없다.

결국, 앱의 코드는 사용자 입력, 네트워크 활동 또는 기타 OS 이벤트와 같은 다양한 외부 요인에 따라 다르게 실행된다. 사용자가 앱을 실행할 때마다 외부 요인에 따라 코드가 완전히 다른 순서로 실행될 수 있다. (앱을 테스트하는 로봇 무리의 경우를 제외하고, 모든 이벤트가 정밀한 킬봇 동기화로 발생할 것으로 예상할 수 있다.)

우리는 확실히 좋은 비동기식 코드를 쓰는 것이 불가능하다고 말하는 것은 아니다. 결국, 위에 나열된 Apple의 훌륭한 API는 매우 진보적이고, 작업에 매우 전문적이며, 공정하고, 다른 플랫폼이 제공하는 것에 비해 상당히 강력하다.

그러나 문제는, Apple의 SDK가 제공하는 다양한 API 때문에 복잡한 비동기 코드를 부분적으로 쓰기가 어렵다.

![](./images/2.png)

예를 들어 델리게이트 패턴 또는 알림 센터와 같은 일부 오

래된 Apple API를 사용하는 경우 주어진 시간에 앱의 상태를 일관되게 유지하기 위해 많은 노력을 기울여야 한다.

(Apple의 Combine을 사용하는 빛나는 새 코드베이스가 있다면 (물론) 이미 반응형 프로그래밍을 사용하고있는 것입니다. 축하합니다.)

이 섹션을 마무리하고 토론을 좀 더 컨텍스트로 만들기 위해 동기 코드와 비동기 코드를 비교할 예정

## 동기 코드

배열의 각 요소에 대해 작업을 수행하는 것: 동기식으로 실행 되고, 컬렉션은 반복하는 동안 변경할 수 없음

→ 컬렉션을 반복 할 때 모든 요소가 아직 있는지 확인할 필요가 없으며, 다른 스레드가 컬렉션의 시작 부분에 요소를 삽입하는 경우 되감을 필요가 없음

```swift
var array = [1, 2, 3]
for number in array {
  print(number)
  array = [4, 5, 6]
}
print(array)
```

- for 루프 안에서 배열의 값이 변경 되는가?
- 루프가 반복하는 컬렉션은 항상 변경 되는가?
- 모든 명령의 실행 순서는? 숫자를 변경할 수 있는가?

### 비동기 코드

버튼을 탭하는 것에 대한 반응으로 반복이 발생한다고 가정

```swift
var array = [1, 2, 3]
var currentIndex = 0

// This method is connected in Interface Builder to a button
@IBAction private func printNext() {
  print(array[currentIndex])
  
  if currentIndex != array.count - 1 {
    currentIndex += 1
  }
}
```

사용자가 버튼을 탭하면 배열의 모든 요소가 인쇄되는가? 

확신할 수 없다. 또 다른 비동기 코드가 배열이 출력되기 전에 마지막 요소를 제거할 수 있다.

또는 다른 코드로 이동한 후 컬렉션 시작 부분에 새 요소를 삽입할 수도 있다.

또한 currentIndex만 변경 되는 것이 아니라, 다른 코드도 수정될 수도 있다.

비동기 코드 작성의 핵심 문제 중 일부는 다음과 같다.

1. 작업이 수행되는 순서
2. 공유 변경 가능한 데이터

## 비동기 프로그래밍 용어집

RxSwift의 일부 언어는 비동기식, 반응형 또는 함수형 프로그래밍에 매우 밀접하게 연결되어 있으므로 다음 기본 용어를 먼저 이해하면 더 쉬울 것이다.

### 1. Shared mutable state

예시로, 노트북을 처음 시작하면 정상적으로 작동한다. 그러나 며칠 또는 몇 주 동안 사용하면 이상하게 작동하거나 갑자기 멈출 수 있다. 

이 때 하드웨어와 소프트웨어는 동일하게 유지되지만, 변경된 것은 상태이다.

재시동하면 같은 조합의 하드웨어와 소프트웨어가 정상적으로 동작한다.

- 메모리의 데이터
- 디스크에 저장된 데이터
- 사용자 입력에 대한 반응의 인공 산물
- 클라우드 서비스에서 더에이터를 가져온 후 남아있는 모든 추적

이들이 당신의 노트북의 상태이다.

여러 비동기 구성 요소 간에 공유되는 앱의 상태를 관리하는 것이 이 책에서 배우게 될 문제이다.

### 2. Imprerative programming

명령형 프로그래밍이란 명령문을 사용하여 프로그램의 상태를 변경하는 프로그래밍 패러다임이다.

ex) 강아지를 훈련시킬 때 '엎드려!', '손!', '기다려!'

명령형 코드를 사용하여 작업을 수행하는 시기와 방법을 앱에 정확히 알려준다.

CPU가 수행하는 모든 작업은 간단한 명령의 긴 시퀀스를 따르는 것. 

명령형 프로그래밍은 컴퓨터가 이해하는 방법과 유사하다. 

문제는 사람이 복잡한 비동기 앱을 위한 명령형 코드를 작성 하는 것이 어려워 진다는 것이다.

특히 공유된 변경 가능 상태를 처리하는 것이 그렇다.

```swift
override func viewDidAppear(_ animated: Bool) {
  super.viewDidAppear(animated)

  setupUI()
  connectUIControls()
  createDataSource()
  listenForChanges()
}
```

- 이 메서드들이 무엇을 하는지 알 수 없다
- 뷰 컨트롤러 자체의 속성을 업데이트 하는가?
- 올바른 순서로 호출되는가? 누군가의 실수로 메서드 호출의 순서를 바꾸어 다르게 동작할 수 있다.

### 3. Side effects

사이드 이펙트는 코드의 현재 범위를 벗어난 상태의 모든 변경을 의미한다.

예시로 주어진 위 코드에서

- `connectUIContols()` 일부 UI component에 일종의 이벤트 핸들러를 첨부할 경우

→ 뷰의 상태가 변경됨. 사이드 이펙트 발생

→ 앱은 `connectUIContols()` 실행 전과 후가 다르게 동작함

- 디스크에 저장된 데이터를 수정
- 화면의 레이블 텍스트를 업데이트

→ 사이드 이펙트 발생

결국 사이드 이펙트를 일으키는 것이 모든 프로그램의 궁극적인 목표.

프로그램이 실행된 후 어떻게 해서든지 상태를 바꿀 필요가 있다. 아무 일도 하지 않는 것은 쓸모 없는 앱이 된다

![](./images/3.png)

사이드 이펙트 생성의 중요한 측면은 통제된 방식으로 수행하는 것

어떤 코드가 사이드 이펙트를 일으키는지, 어떤 코드가 단순히 데이터를 처리/출력하는지 확인할 수 있어야 함

### 4. Declarative code

명령형 프로그래밍에서는 마음대로 상태를 변경한다.

함수형 프로그래밍에서는 사이드 이펙트를 일으키는 코드를 최소화하는 것을 목표로 한다.

RxSwift는 이 두 가지 프로그래밍의 가장 좋은 측면을 결합했다

선언적 코드를 사용하면 동작의 일부를 정의 할 수 있다

RxSwift는 관련 이벤트가있을 때마다 이러한 동작을 실행하고 작업 할 불변의 독립된 데이터 조각을 제공

이렇게하면 비동기 코드로 작업 할 수 있지만 단순 for 루프에서와 동일한 가정을 할 수 있음 (변경 불가능한 데이터, 순차적이고 결정적인 방식의 코드 실행)

### 5. Reactive systems

- Responsive: 항상 앱 상태를 나타내는 UI를 최신으로 유지
- Resilient: 각 동작은 독립되어 정의. 유연한 오류 복구 제공
- Elastic: 코드는 다양한 워크로드로 처리됨. lazy pull-driven data collections, event throttling, resouce sharing
- Message driven: component는 향상된 재사용 및 독립을 위해 메시지 기반 통신을 사용하여 lifecycle과 클래스 구현을 분리한다

# 1.2 RxSwift의 기초

반응형 프로그래밍은 새로운 개념이 아니다. 꽤 오랫동안 사용되어 왔지만 학샘 개념은 근 10년 간 눈에 띄게 주목받았다. 그 기간동안 웹앱은 복잡한 비동기 UI 관리 문제와 마주했다

MicroSoft의 한 팀에서 비동기, 확장 가능한 실시간 앱 개발의 문제를 해결하는데 도전했다

.NET 용 Rx는 2012 년부터 오픈 소스가되어 다른 언어와 플랫폼이 동일한 기능을 다시 구현할 수있게하여 Rx를 플랫폼 간 표준으로 전환했다

오늘날 RxJS, RxKotlin, [Rx.NET](http://rx.net/), RxScala, RxSwift 등이 존재하고 모두 Reactive Extensions 사양을 기반으로 동일한 동작과 동일한 표현 API를 구현하고자 한다

RxSwift는 전통적으로 필수적인 코코아 코드와 순수 기능 코드 사이의 달콤한 지점을 찾는다. 이를 통해 고정 코드 정의를 사용하여 비동기로 입력 조각을 결정적이고 구성 가능한 방식으로 처리함으로써 이벤트에 대응할 수 있게 된다

Rx 구현 제품군에 대한 자세한 내용은 [http://reactivex.io에서](http://reactivex.xn--io-q04jk9m/) 확인할 수 있다. Rx의 연산자 및 코어 클래스에 대한 문서의 중앙 저장소이며 Rx 로고, 전기 뱀장어(이 책의 표지에서 볼 수 있는 약간 더 사실적인 이미지)를 가장 먼저 볼 수 있다

![](./images/4.png)
Rx 코드의 세 가지 구성 요소는 다음과 같다:

 `observables` , `operators`, `schedulers`

## Observables

## Operators

## Schedulers